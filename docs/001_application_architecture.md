このドキュメントは本プロジェクトのアプリケーション・アーキテクチャについて記載しています。

# 1. 概要

本ドキュメントは、IT技術系個人ブログアプリケーションのシステムアーキテクチャについて説明します。このアプリケーションは **Next.js を用いた静的サイトジェネレーション (SSG)** を採用し、**コンテンツを Git リポジトリ内の Markdown ファイルで管理する**ことで、効率的な記事公開プラットフォームを提供します。

## 2. アーキテクチャの概要

### 2.1 アーキテクチャスタイル

本アプリケーションは、以下のアーキテクチャスタイルを採用しています：

- **静的サイトジェネレーション (SSG)**: Next.js を利用し、ビルド時にコンテンツから静的な HTML、CSS、JavaScript ファイルを生成します。これにより高速なページ表示とスケーラビリティを実現します。
- **コンテンツ駆動アーキテクチャ**: アプリケーションの構造と表示は、`src/content/` ディレクトリ内の Markdown ファイルとその Front Matter によって駆動されます。
- **フィーチャベースアーキテクチャ**: UIコンポーネントや関連ロジックを機能ごとに整理するアプローチ (`src/features/`)。
- **ユーティリティファースト**: コンテンツ処理や共通機能は `src/lib/` 内のユーティリティ関数群として実装します。

### 2.2 主要技術

- **フレームワーク**: Next.js (App Router)
- **言語**: TypeScript
- **UIライブラリ**: shadcn-ui, Tailwind CSS
- **コンテンツ処理**: gray-matter (Front Matter パース), react-markdown (Markdown レンダリング), remark/rehype プラグイン
- **検索**: flexsearch (クライアントサイド検索)
- **ホスティング**: Vercel (Git 連携による自動デプロイ)

## 3. ディレクトリ構造の設計原則

### 3.1 フィーチャベースのコンポーネント構成

アプリケーションのUIは、機能（フィーチャ）ごとにコンポーネントを整理します (`src/features/`)。これにより、特定の機能に関連するUI部品のまとまりを保ち、保守性を向上させます。

主要なフィーチャディレクトリには、記事表示 (`post`)、カテゴリ表示 (`category`)、タグ表示 (`tag`)、検索 (`search`) などがあります。**認証 (`auth`) や管理画面関連のフィーチャは存在しません。**

### 3.2 レイヤー分離 (簡略化)

従来の多層アーキテクチャ（サービス層、リポジトリ層）は、**DB を使用しないため大幅に簡略化**されます。

- **UI層 (`src/app`, `src/features`, `src/components`)**: Next.js の App Router によるルーティング定義、および React コンポーネントによる UI 構築。Server Components (SSG) が主体となり、インタラクションが必要な箇所のみ Client Components を使用します。
- **コンテンツ処理層 (`src/lib`)**: ビルド時に Markdown ファイルを読み込み、パースし、必要なデータ構造（記事一覧、タグ一覧など）を生成するユーティリティ関数群。
- **型定義 (`src/types`, `src/features/**/_types`)**: アプリケーション全体およびフィーチャ固有の型定義。

**Server Actions や API Routes は、コアなコンテンツ表示機能には基本的に使用しません。**

### 3.3 ディレクトリベースのルーティング

Next.js App Router のディレクトリベースルーティングを採用します。

- **公開ルート (`src/app/(routes)`)**: ユーザーがアクセスするページのルート定義（トップ、ブログ記事一覧、記事詳細、カテゴリ別、タグ別など）。
- **管理ルート (`src/app/(admin)`)**: **存在しません。**
- **APIルート (`src/app/api`)**: **基本的に使用しません。**

## 4. 主要な処理フロー

### 4.1 コンテンツのビルド時処理

1.  Next.js のビルドプロセス (`next build`) が開始されます。
2.  `src/lib/` 内のユーティリティ関数が `src/content/posts/` ディレクトリをスキャンします。
3.  各 Markdown ファイルについて、`gray-matter` を使用して Front Matter と本文をパースします。
4.  パースされたデータ（全記事リスト、カテゴリリスト、タグリストなど）が生成されます。
5.  `generateStaticParams` を使用して、記事詳細ページなどの動的ルートに対応する静的パスが生成されます。
6.  各ページの Server Components が、ビルド時に取得したデータを用いてレンダリングされ、静的な HTML ファイルが生成されます。
7.  検索用のインデックスファイル (`public/search-index.json`) が `flexsearch` を用いて生成されます (別スクリプト実行)。

### 4.2 ページ表示

1.  ユーザーがサイトにアクセスします。
2.  Vercel から事前に生成された静的ファイル (HTML, CSS, JS) が配信されます。
3.  ブラウザが HTML を表示し、必要に応じて Client Components がハイドレーションされます。

### 4.3 検索処理

1.  ユーザーが検索コンポーネント (`Client Component`) を操作します。
2.  検索コンポーネントは `public/search-index.json` を非同期に取得します。
3.  取得したインデックスを `flexsearch` でロードし、ユーザー入力に基づいて検索を実行します。
4.  検索結果が動的に表示されます。